summary(lm(data=landrent, Y ~ X1 + X2 + X3))
summary(lm(data=landrent, Y ~ X1 + X2 + X4))
lm_f <- lm(data=landrent, Y ~ X1 + X2)
summary(lm_f)
scatterplot(landrent)
scatterplot(landrent$X1, landrent$Y)
scatterplot(landrent$Y~landrent$X1)
scatterplot(landrent$Y~landrent$X1+landrent$X2)
residualPlot(lm_f)
plot(lm_f$residuals, xlab="Sequence", ylab="Residuals",
main="Sequence Plot")
par(mfrow=c(1,2))
plot(stdres(lm_f), xlab="", ylab="",
main="Standardized Residual Plot")
library(MASS)
detach(MASS)
detach("MASS")
detach("package:MASS", unload=TRUE)
par(mfrow=c(1,2))
plot(MASS::stdres(lm_f), xlab="", ylab="",
main="Standardized Residual Plot")
abline(h=0)
plot(MASS::studres(lm_f), xlab="", ylab="",
main="Studentized Residual Plot")
abline(h=0)
par(mfrow=c(1,1))
residplot <- function(fit, nbreaks=10) {
z <- rstudent(fit)
hist(z, breaks=nbreaks, freq=FALSE,
xlab="Studentized Residual",
main="Distribution of Errors")
rug(jitter(z), col="brown")
curve(dnorm(x, mean=mean(z), sd=sd(z)),
add=TRUE, col="blue", lwd=2)
lines(density(z)$x, density(z)$y,
col="red", lwd=2, lty=2)
legend("topright",
legend = c( "Normal Curve", "Kernel Density Curve"),
lty=1:2, col=c("blue","red"), cex=.7)
}
residplot(lm_f)
shapiro.test(lm_UN$residuals)
shapiro.test(lm_f$residuals)
qqPlot(residuals(lm_f), main="landrent: Normal QQ-Plot", xlab="", ylab="")
residualPlot(lm_f)
plot(lm_f$residuals, xlab="Sequence", ylab="Residuals",
main="Sequence Plot")
par(mfrow=c(1,2))
plot(MASS::stdres(lm_f), xlab="", ylab="",
main="Standardized Residual Plot")
abline(h=0)
plot(MASS::studres(lm_f), xlab="", ylab="",
main="Studentized Residual Plot")
abline(h=0)
plot(landrent)
par(mfrow=c(1,2))
plot(MASS::stdres(lm_f), xlab="Standardized Residual", ylab="Sequence",
main="Standardized Residual Plot")
abline(h=0)
plot(MASS::studres(lm_f), xlab="Studentized Residual", ylab="Sequence",
main="Studentized Residual Plot")
abline(h=0)
par(mfrow=c(1,1))
residplot <- function(fit, nbreaks=10) {
z <- rstudent(fit)
hist(z, breaks=nbreaks, freq=FALSE,
xlab="Studentized Residual",
main="Distribution of Errors")
rug(jitter(z), col="brown")
curve(dnorm(x, mean=mean(z), sd=sd(z)),
add=TRUE, col="blue", lwd=2)
lines(density(z)$x, density(z)$y,
col="red", lwd=2, lty=2)
legend("topright",
legend = c( "Normal Curve", "Kernel Density Curve"),
lty=1:2, col=c("blue","red"), cex=.7)
}
residplot(lm_f)
plot(lm_f$residuals, xlab="Sequence", ylab="Residuals",
main="Sequence Plot")
par(mfrow=c(1,2))
plot(MASS::stdres(lm_f), xlab="Standardized Residual", ylab="Sequence",
main="Standardized Residual Plot")
abline(h=0)
plot(MASS::studres(lm_f), xlab="Studentized Residual", ylab="Sequence",
main="Studentized Residual Plot")
abline(h=0)
par(mfrow=c(1,2))
plot(MASS::stdres(lm_f), xlab="Sequence", ylab="Standardized Residual",
main="Standardized Residual Plot")
abline(h=0)
plot(MASS::studres(lm_f), xlab="Sequence", ylab="Studentized Residual",
main="Studentized Residual Plot")
abline(h=0)
landrent
bptest(lm_f)
lm_test::bptest(lm_f)
lmtest::bptest(lm_f)
residualPlot(lm_f)
par(mfrow=c(1,1))
residualPlot(lm_f)
landrent$X1
median(landrent$X1)
median(landrent$X2)
landrent
landrent$Group <- factor(apply(landrent, 1, function(x){
if(x[1]<=44.56){return(0)} else{return(1)}}))
landrent
leveneTest(data=landrent, Y ~ Group, center=median)
lm3 <- lm(data=landrent, Y ~ X1 + X2 + X3)
summary(lm3)
lm4 <- lm(data=landrent, Y ~ X1 + X2 + X4)
summary(lm3)
summary(lm_f)
qqPlot(residuals(lm_f), main="landrent: Normal QQ-Plot", xlab="", ylab="")
residplot(lm_f)
leveneTest(data=landrent, Y ~ Group, center=median)
shapiro.test(lm_f$residuals)
lm3 <- lm(data=landrent, Y ~ X1 + X2 + X3)
summary(lm3)
summary(lm_f)
summary(lm3)
lm4 <- lm(data=landrent, Y ~ X1 + X2 + X4)
summary(lm3)
summary(lm34
)
summary(lm4)
summary(lm1)
summary(lm(data=landrent, Y ~ X1 + X3)
)
rm(list=ls())
cat("\014")
rateprof <- alr4::Rateprof
detach("package:car", unload=TRUE)
transaction <- Transact
transaction <- alr4::Transact
normal <- rnorm(5000, 0, 1) + c(1, 0, 2, 0, 1)
plot(normal)
shapiro.test(normal)
normal <- rnorm(5000, 0, 1) + c(1, 0, 2, 0, 1)
shapiro.test(normal)
non_normal <- runif(10)
non_normal
dist(non_normal)
hist(non_normal)
shapiro.test(non_normal)
non_normal <- runif(10)
shapiro.test(non_normal)
hist(non_normal)
non_normal <- replicate(1000, shapiro.test(runif(10))$p.value)
rowMeans(non_normal<0.05)
non_normal<0.05
sum(non_normal<0.05)
sum(non_normal<0.05)/1000
non_normal <- replicate(5000, shapiro.test(runif(10))$p.value)
sum(non_normal<0.05)/1000
sum(non_normal<0.05)/5000
non_normal <- replicate(5000, shapiro.test(runif(10))$p.value)
sum(non_normal<0.05)/length(non_normal)
normal <- rnorm(5000, 0, 1) + runif(5000, 1, 2)
normal <- replicate(rnorm(5000, 0, 1))# + runif(5000, 1, 2)
normal <- replicate(5000, rnorm(5000, 0, 1))# + runif(5000, 1, 2)
normal <- replicate(5000, shapiro.test(rnorm(5000, 0, 1))$p.value)# + runif(5000, 1, 2)
sum(normal<0.05)/length(normal)
sum(non_normal<0.05)/length(non_normal) * 100
sum(normal<0.05)/length(normal) * 100
sum(non_normal>0.05)/length(non_normal) * 100 # percent of times non-normal data is considered normal
sum(normal<0.05)/length(normal) * 100 # percent of times normal data is considered non-normal
install.packages("leaps")
install.packages("xlsx")
install.packages("rJava")
install.packages("xlsx")
library(xlsx)
library(rJava)
install.packages("rJava")
library(xlsx)
library(rJava)
Sys.getenv("JAVA_HOME")
install.packages("QuantPsyc")
setwd("~/Documents/Module2/msan604/A1")
sales <- read.table('SALES.txt'')
sales <- read.table('SALES.txt')
sales <- ts(sales, start=1999, frequency=12)
plot(sales)
t <- time(sales) # Extracting time as the explanatory variate from the time series framework of data
cycle(sales) # Introducing month as the season
month <- as.factor(cycle(sales)) # Introducing month as the season
par(mfrow=c(3,1)) # Dividing the plotting page into 3 panels
quad <- lm(AirPassengers~t+I(t^2)) # Just model linear trend
summary(quad)
plot(AirPassengers)
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
quad <- lm(sales~t+I(t^2)) # Just model linear trend
summary(quad)
plot(sales)
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
par(mfrow=c(1,1)) # Dividing the plotting page into 3 panels
quad <- lm(sales~t+I(t^2)) # Just model linear trend
summary(quad)
plot(sales)
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
quad <- lm(sales~t+I(t^2)) # Just model linear trend
summary(quad)
plot(salesylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
plot(salesy, lab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
ts.plot(sales)
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
quad <- lm(sales~I(t^2)) # model quadratic trend
summary(quad)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for quad model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
quad <- lm(sales~t+I(t^2)) # model quadratic trend
summary(quad)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for quad model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
seas <- lm(sales~t+I(t^2)+month) # model quadratic trend + seasonality
summary(seas)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
par(mfrow=c(1,1))
seas <- lm(sales~t+I(t^2)+month) # model quadratic trend + seasonality
summary(seas)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for seas model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(seas$fitted, seas$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(seas$residuals) #qq-plot of residuals
qqline(seas$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(seas$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(seas$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
anova(quad, seas)
plot(sales)
par(mfrow=c(1,1))
plot(sales)
month
cycle(sales)
t.new <- seq(2011,2012,length=12)[1:12]
t.new
seq(2011,2012,length=12)
t.new <- seq(2011,2012,length=12)[1:11]
t.new
sales
cycle(sales)
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
seq(2011,2012,length=13)
t.new <- seq(2011,2012,length=13)[1:12]
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
pred <- predict.lm(reg4,new,interval='prediction') # Computing the prediction as well as prediction interval
pred <- predict.lm(seas,new,interval='prediction') # Computing the prediction as well as prediction interval
plot(sales, xlim=c(2000,2012), ylim=c(0,70)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(exp(pred[,1])~t.new, type='l', col='red')# plotting the predict
lines(exp(pred[,2])~t.new, col='green') # plotting lower limit of the prediction interval
lines(exp(pred[,3])~t.new, col='green') # plotting upper limit of the  prediction interval
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
sales
plot(sales, xlim=c(1999,2012), ylim=c(0,70)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 60)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
rm(list=ls())
cat("\014")
sales <- read.table('SALES.txt')
sales <- ts(sales, start=1999, frequency=12)
plot(sales, ylab='Sales', main='Monthly Sales')
#a
t <- time(sales) # Extracting time as the explanatory variate from the time series framework of data
quad <- lm(sales~t+I(t^2)) # model quadratic trend
summary(quad)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for quad model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
# higher density of points on the left
# qq-plot OK
# maybe not independent?
# seasonality
par(mfrow=c(1,1))
#b
cycle(sales) # Introducing month as the season
month <- as.factor(cycle(sales)) # Introducing month as the season
seas <- lm(sales~t+I(t^2)+month) # model quadratic trend + seasonality
summary(seas)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for seas model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(seas$fitted, seas$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(seas$residuals) #qq-plot of residuals
qqline(seas$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(seas$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(seas$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
# higher density on the left
# qq-plot OK
# independent
# exponential decay -> AR(1)?
par(mfrow=c(1,1))
#c
anova(quad, seas)
# Don't know if this is what we're supposed to do here
#d
# what?
#e
#Prediction in sales data
t.new <- seq(2011,2012,length=13)[1:12]
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
pred <- predict.lm(seas, new, interval='prediction') # Computing the prediction as well as prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, ylab='Sales', main='Quadratic trend of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
par(mfrow=c(1,1))
#b
cycle(sales) # Introducing month as the season
month <- as.factor(cycle(sales)) # Introducing month as the season
seas <- lm(sales~t+I(t^2)+month) # model quadratic trend + seasonality
summary(seas)
plot(sales, ylab='Sales', main='Quadratic trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
plot(sales, ylab='Sales', main='Quadratic and seasonal trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(seas$fitted, seas$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(seas$residuals) #qq-plot of residuals
qqline(seas$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(seas$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(seas$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
t.new <- seq(2011,2012,length=13)[1:12]
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
pred <- predict.lm(seas, new, interval='prediction') # Computing the prediction as well as prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
par(mfrow=c(1,1))
#e
#Prediction in sales data
t.new <- seq(2011,2012,length=13)[1:12]
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
pred <- predict.lm(seas, new, interval='prediction') # Computing the prediction as well as prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65)) #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65), ylab='Sales', main='Predicting sales for 2011') #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65), ylab='Sales', main='Sales prediction for 2011') #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
cycle(sales) # Introducing month as the season
rm(list=ls())
cat("\014")
sales <- read.table('SALES.txt')
sales <- ts(sales, start=1999, frequency=12)
plot(sales, ylab='Sales', main='Monthly Sales')
#a
t <- time(sales) # Extracting time as the explanatory variate from the time series framework of data
quad <- lm(sales~t+I(t^2)) # model quadratic trend
summary(quad)
plot(sales, ylab='Sales', main='Quadratic trend of monthly sales')
points(t,predict.lm(quad), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for quad model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(quad$fitted, quad$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(quad$residuals) #qq-plot of residuals
qqline(quad$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(quad$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(quad$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
# higher density of points on the left
# qq-plot OK
# maybe not independent?
# seasonality
par(mfrow=c(1,1))
#b
cycle(sales) # Introducing month as the season
month <- as.factor(cycle(sales)) # Introducing month as the season
seas <- lm(sales~t+I(t^2)+month) # model quadratic trend + seasonality
summary(seas)
plot(sales, ylab='Sales', main='Quadratic and seasonal trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red') # superimpose the fit of model reg0 on the plot of the data
# Diagnostic plots for seas model
par(mfrow=c(2,2)) # Dividing the plotting page into 4 panels
plot(seas$fitted, seas$residuals, main = "Residuals vs. Fitted Values", ylab = "Residuals", xlab = "Fitted Values") # plot of fitted values vs residuals
abline(h = 0, col = "red", lwd = 2)
qqnorm(seas$residuals) #qq-plot of residuals
qqline(seas$residuals, col = "red") # plotting the line, along which the dots in qq-plot should lie
plot(seas$residuals, main = "Residuals vs. Time", ylab = "Residuals", xlab = "Time") # plotting the residuals vs time
abline(h = 0, col = "red", lwd = 2) # plotting a horizontal line at 0
acf(seas$residuals, main = "ACF Plot of Residuals") #sample acf plot of residuals
# higher density on the left
# qq-plot OK
# independent
# exponential decay -> AR(1)?
#c
anova(quad, seas)
# Don't know if this is what we're supposed to do here
#d
# what?
par(mfrow=c(1,1))
#e
#Prediction in sales data
t.new <- seq(2011,2012,length=13)[1:12]
t2.new <- t.new^2
month.new <- factor(1:12) # Introducing the seasonal value for forecasting
new <- data.frame(t=t.new, t2=t2.new, month=month.new) # Putting the values for forecasting into a dataframe
pred <- predict.lm(seas, new, interval='prediction') # Computing the prediction as well as prediction interval
plot(sales, xlim=c(1999,2012), ylim=c(0, 65), ylab='Sales', main='Sales prediction for 2011') #plotting the data
abline(v=2011, col='blue', lty=2) # adding a vertical line at the point where prediction starts
lines(pred[,1]~t.new, type='l', col='red')# plotting the predict
lines(pred[,2]~t.new, col='green') # plotting lower limit of the prediction interval
lines(pred[,3]~t.new, col='green') # plotting upper limit of the  prediction interval
summary(quad)
summary(seas)
par(mfrow=c(1,2))
plot(sales, ylab='Sales', main='Quadratic trend of monthly sales')
points(t,predict.lm(quad), type='l', col='red')
plot(sales, ylab='Sales', main='Quadratic and seasonal trends of monthly sales')
points(t,predict.lm(seas), type='l', col='red')
AIC(quad)
AIC(seas)
anova(quad, seas)
